Registers
---------
R0-R15: General purpose use
RI0-RI7: General purpose use for interrupts only
RC: Carry flag
RO: 0x00.. register
RF: 0xFF.. register
RSP: Address of the current stack position
RIP: Address of the current instruction
RSIP: Address of the instruction executing when an interrupt fires
RCFG: Physical address of the processor configuration table
RIDT: Physical address of the interrupt descriptor table
RMDT: Physical address of the memory descriptor table
RTDT: Physical address of the task descriptor table
RINT: Data made available from an interrupt

CFG
---
2b: system tick interval
2b: cached instructions
1b: protection mode (0 = no protection, 1 = protected)

IDT
---
0x00: Invalid instruction
0x01: Divide by zero
0x02: System call
0x03: Protection violation
0x04: Page not present
0x05: System timer
0x06: Device waiting
0x07-0x0F: Reserved
0x10-0xFF: User defined

Instruction Format
------------------
8b Code: The instruction code
2b Size: 0 = 1 byte, 1 = 2 byte, 2 = 4 byte, 3 = 8 byte
9b Parameters: 3 bits per parameter.
    3b Type: 0 = register, 1 = register value as address to dereference, 2 = literal value, 3 = literal value as address to dereference, 4 = taken from stack, 5 = calculated value as address to dereference (base + index * scale + offset).
0b-280b Parameter data: Parameter values in order of appearance

Calculated Parameter
--------------------
First byte is the format. Each field is one bit: has index (default 0), has scale (default 1), has offset (default 0), register/literal base, register/literal index, register/literal scale, register/literal offset, positive/negative index

Basic
-----
00 HLT: Stops the processor
01 NOP: No operation
02 INT A: Raise the interrupt specified by A
03 INTE: Enables interrupts
04 INTD: Disables interrupts
05 EINT: Return from the interrupt
06 MOV A B: Move A into B
07 XCHG A B: Swap A and B
08 IN A B: Read from device ID specified in A into B
09 OUT A B: Write to device ID specified in A from B
10 JZ A B: Sets RIP to B if A is zero
11 JNZ A B: Sets RIP to B if A is non-zero
12 JMP A: Sets RIP to A
13 PUSH A: Push A onto the stack
14 POP A: Pop a value from the stack into A

Math
----
20 ADD A B C: Add A to B and store in C
21 ADDC A B C: Add A with carry to B and store in C
22 ADDF A B C: Add the IEEE 754 value in A to B and store in C
23 SUB A B C: Subtract A from B and store in C
24 SUBC A B C: Subtract A with borrow from B and store in C
25 SUBF A B C: Subtract the IEEE 754 value in A from B and store in C
26 DIV A B C: Divide B by A and store in C
27 DIVF A B C: Divide B by the IEEE 754 value in A and store in C
28 MUL A B C: Multiply B by A and store in C
29 MULF A B C: Multiply B by the IEEE 754 value in A and store in C
30 MOD A B C: Take the remainder of dividing B by A and store in C
31 MODF A B C: Take the remainder of dividing B by the IEEE 754 value in A and store in C

Logic
-----
40 SR A B C: Shift B right by A and store in C
41 SL A B C: Shift B left by A and store in C
42 RR A B C: Rotate B right by A and store in C
43 RL A B C: Rotate B left by A and store in C
44 NAND A B C: Store the NAND of A and B in C
45 AND A B C: Store the AND of A and B in C
46 NOR A B C: Store the NOR of A and B in C
47 OR A B C: Store the OR of A and B in C
48 NXOR A B C: Store the NXOR of A and B in C
49 XOR A B C: Store the XOR of A and B in C
50 NOT A B: Store the NOT of A in B
51 GT A B C: Store in C if B is greater than A
52 GTE A B C: Store in C if B is greater than or equal to A
53 LT A B C: Store in C if B is less than A
54 LTE A B C: Store in C if B is less than or equal to A
55 EQ A B C: Store in C if B is equal to A
56 NEQ A B C: Store in C if B is not equal to A

Debug
-----
60 DBG A: Debug use
61 PAU: Pause execution