=========
Registers
=========
R0-R15: General purpose use
RI0-RI7: General purpose use for interrupts only
RZERO: 0x0 register
RONE: 0x1 register
RMAX: 0xFF.. register
RSP: Address of the current stack position
RIP: Address of the current instruction
RSIP: Address of the instruction executing when an interrupt fires
RINT1: Data made available from an interrupt
RINT2: Data made available from an interrupt

=============
Configuration
=============
0x00: System tick interval
0x01: Instruction cache size

==========
Interrupts
==========
0x00: Invalid instruction (Code, Address)
0x01: Divide by zero (Address)
0x02: System call
0x04: System timer
0x05: Device waiting (Device, Data)
0x06: CPY complete (Source, Destination)
0x07-0xFF: Reserved
0x100-0xFFF: Undefined

==================
Instruction Format
==================
Each instruction begins with one word. Calculated and literal values are embedded recursively as they appear. There is no limit on how far calculated parameters can recurse.

Base
----
8b Code
27b Parameters (9b each)
    1b is RIP relative (before indirection)
    1b is indirect
    2b type (0 = calculated, 1 = register, 2 = literal, 3 = stack)
    5b register
11b Conditional
    1b is enabled
    1b is zero
    1b is RIP relative (before indirection)
    1b is indirect
    2b type (0 = calculated, 1 = register, 2 = literal, 3 = stack)
    5b register
18b Reserved

Calculated Parameter
--------------------
40b Parameters (10b each, format of [base + index * scale + offset])
    1b is positive
    1b is RIP relative (before indirection)
    1b is indirect
    2b type (0 = calculated, 1 = register, 2 = literal, 3 = stack)
    5b register
24b Reserved

============
Instructions
============

Basic
-----
00 HLT: Stops the processor
01 NOP: No operation
02 INT A B C: Raise the interrupt specified by A passing B to RINT1 and C to RINT2
03 EINT: Return from the interrupt
04 INTE: Enables interrupts
05 INTD: Disables interrupts
06 XCHG A B: Swap A and B
07 CAS A B C: If A and B are equal, set A to C, else set B to A
08 SET A B: Set A to B
09 CPY A B C: Copy C bytes from B into A

Math
----
20 ADD A B C: Set A to A + B
21 ADDF A B C: Set A to B + C interpreting each as an IEEE 754 value
22 SUB A B C: Set A to B - C
23 SUBF A B C: Set A to B - C interpreting each as an IEEE 754 value
24 DIV A B C: Set A to B / C
25 DIVF A B C: Set A to B / C interpreting each as an IEEE 754 value
26 MUL A B C: Set A to B * C
27 MULF A B C: Set A to B * C interpreting each as an IEEE 754 value
28 MOD A B C: Set A to B % C
29 MODF A B C: Set A to B % C interpreting each as an IEEE 754 value
30 ITOF A B: Convert the integer B to an IEEE 754 value and store it in A
31 FTOI A B: Convert the IEEE 754 value in B to an integer and store it in A

Logic
-----
40 SR A B C: Set A to B >> C
41 SL A B C: Set A to B << C
42 RR A B C: Set A to B >> C rotating in the removed bits
43 RL A B C: Set A to B << C rotating in the removed bits
44 NAND A B C: Set A to !(B & C)
45 AND A B C: Set A to B & C
46 NOR A B C: Set A to !(B | C)
47 OR A B C: Set A to B | C
48 NXOR A B C: Set A to !(B ^ C)
49 XOR A B C: Set A to B ^ C
50 NOT A B: Set A to !B
51 GT A B C: Set A to B > C
52 GTE A B C: Set A to B >= C
53 LT A B C: Set A to B < C
54 LTE A B C: Set A to B <= C
55 EQ A B C: Set A to B == C
56 NEQ A B C: Set A to B != C

Debug
-----
60 DBG A B C: Debug use
61 BRK: Break execution

=======
Devices
=======

Interrupt Controller
--------------------
Each address stores the address of the the interrupt handler for the respective vector. For example, address 2 contains the address of the handler for interrupt 2. Enqueuing and dequeueing interrupts occurs outside the system bus.