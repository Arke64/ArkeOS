Registers
---------
R0-R15: General purpose use
RI0-RI7: General purpose use for interrupts only
RZ: Zero flag
RS: Sign flag
RC: Carry flag
RO: 0x00.. register
RF: 0xFF.. register
RCFG: Physical address of the processor configuration table
RSIP: Address of the instruction executing when an interrupt fires
RIP: Address of the current instruction
RSP: Address of the current stack position
RIDT: Physical address of the interrupt descriptor table
RMDT: Physical address of the memory descriptor table
RTDT: Physical address of the task descriptor table

CFG
---
2b: system tick interval
2b: cached instructions
1b: protection mode (0 = no protection, 1 = protected)

IDT
---
0x00: Invalid instruction
0x01: Divide by zero
0x02: System call
0x03: Protection violation
0x04: Page not present
0x05: System timer
0x06: Device waiting
0x07-0x0F: Reserved
0x10-0xFF: User defined

Format
------
6b Code: The instruction code
2b Size: The size of data to work with (00 = 1 byte, 01 = 2 byte, 10 = 4 byte, 11 = 8 byte)
2b Parameter 0: The type of the parameter (00 = value in register, 01 = immediate value with size specified by Size, 10 = value at literal address, 11 = value at address specified by register)
2b Parameter 1: See above
2b Parameter 2: See above
2b Parameter 3: See above
0b-64b: Parameters

Basic
-----
00 HLT: Stops the processor
01 NOP: No operation
02 INT A: Raise the interrupt specified by A
03 EINT: Return from the interrupt
04 MOV A B: Move A into B
05 XCHG A B: Swap A and B
06 IN A B: Read from device ID specified in A into B
07 OUT A B: Write to device ID specified in A from B
08 PUSH A: Push A onto the stack
09 POP A: Pop a value from the stack into A
10 JZ A B: Sets RIP to B if A is zero
11 JNZ A B: Sets RIP to B if A is non-zero
12 JMP A: Sets RIP to A
13 CALL A: Pushes RIP + instruction length to the stack and sets RIP to A
14 RET: Pops a value from the stack and stores in RIP
15 INTE: Enables interrupts
16 INTD: Disables interrupts

Math
----
20 ADD A B C: Add A to B and store in C
21 ADC A B C: Add A with carry to B and store in C
22 ADF A B C: Add the IEEE 754 value in A to B and store in C
23 SUB A B C: Subtract A from B and store in C
24 SBB A B C: Subtract A with borrow from B and store in C
25 SBF A B C: Subtract the IEEE 754 value in A from B and store in C
26 DIV A B C: Divide B by A and store in C
27 DVF A B C: Divide B by the IEEE 754 value in A and store in C
28 MUL A B C: Multiply B by A and store in C
29 MLF A B C: Multiply B by the IEEE 754 value in A and store in C
30 INC A B: Add 1 to A and store in B
31 DEC A B: Subtract 1 from A and store in B
32 NEG A B: Reverse the sign of A and store in B
33 MOD A B C: Take the remainder of dividing B by A and store in C
34 MDF A B C: Take the remainder of dividing B by the IEEE 754 value in A and store in C

Logic
-----
40 SR A B C: Shift B right by A and store in C
41 SL A B C: Shift B left by A and store in C
42 RR A B C: Rotate B right by A and store in C
43 RL A B C: Rotate B left by A and store in C
44 NAND A B C: Store the NAND of A and B in C
45 AND A B C: Store the AND of A and B in C
46 NOR A B C: Store the NOR of A and B in C
47 OR A B C: Store the OR of A and B in C
48 NXOR A B C: Store the NXOR of A and B in C
49 XOR A B C: Store the XOR of A and B in C
50 NOT A B: Store the NOT of A in B
51 GT A B: Update RZ to reflect if B is greater than A
52 GTE A B: Update RZ to reflect if B is greater than or equal to A
53 LT A B: Update RZ to reflect if B is less than A
54 LTE A B: Update RZ to reflect if B is less than or equal to A
55 EQ A B: Update RZ to reflect if B is equal to A
56 NEQ A B: Update RZ to reflect if B is not equal to A

Debug
-----
60 DBG A: Debug use
61 PAU: Pause execution