Registers
---------
R0-R15: General purpose use
RI0-RI7: General purpose use for interrupts only
RO: 0x00.. register
RF: 0xFF.. register
RSP: Address of the current stack position
RIP: Address of the current instruction
RSIP: Address of the instruction executing when an interrupt fires
RINT1: Data made available from an interrupt
RINT2: Data made available from an interrupt

Configuration
--------------
0x00: Protection mode
0x01: System tick interval
0x02: Allow instruction caching
0x100-0x1FF: Interrupt vectors

Interrupts
----------
0x00: Invalid instruction
0x01: Divide by zero
0x02: System call
0x04: System timer
0x05: Device waiting
0x06-0x0F: Reserved
0x10-0xFF: Undefined

Instruction Format
------------------
Each instruction is one word followed by three optional literal words (13 if using three calculated parameters).

8b Code
8b Reserved
24b Registers (8b each)
15b Reserved
9b Parameter types (3b each)
    0 = calculated value (base + index * scale + offset), 
    1 = register, 
    2 = literal value, 
    3 = stack, 
    4 = calculated value as address to dereference, 
    5 = register value as address to dereference, 
    6 = literal value as address to dereference, 
    7 = stack value as address to dereference,
0b-768b Parameters: Calculated parameters and literals in order of appearance

Calculated Parameter
--------------------
16b Format (4b for each operand where first 3 are the same as parameter type above (except 0 is default and 4 is not defined) and the fourth is a sign bit)
32b Register operands
16b Reserved
0b-256b Literal operands

Basic
-----
00 HLT: Stops the processor
01 NOP: No operation
02 INT A B: Raise the interrupt specified by A passing B to RINT1 and C to RINT2
03 EINT: Return from the interrupt
04 INTE: Enables interrupts
05 INTD: Disables interrupts
06 XCHG A B: Swap A and B
07 CAS A B C: If C and B are equal, set C to A, else set B to C
08 MOV A B: Move A into B
09 MVZ A B C: Moves B into C if A is zero
10 MVNZ A B C: Moves B into C if A is non-zero
11 ADZ A B C: Adds B to C if A is zero
12 ADNZ A B C: Adds B to C if A is non-zero
13 SBZ A B C: Subtracts B from C if A is zero
14 SBNZ A B C: Subtracts B from C if A is non-zero

Math
----
20 ADD A B C: Add A to B and store in C
21 ADDF A B C: Add the IEEE 754 value in A to B and store in C
22 SUB A B C: Subtract A from B and store in C
23 SUBF A B C: Subtract the IEEE 754 value in A from B and store in C
24 DIV A B C: Divide B by A and store in C
25 DIVF A B C: Divide B by the IEEE 754 value in A and store in C
26 MUL A B C: Multiply B by A and store in C
27 MULF A B C: Multiply B by the IEEE 754 value in A and store in C
28 MOD A B C: Take the remainder of dividing B by A and store in C
29 MODF A B C: Take the remainder of dividing B by the IEEE 754 value in A and store in C

Logic
-----
40 SR A B C: Shift B right by A and store in C
41 SL A B C: Shift B left by A and store in C
42 RR A B C: Rotate B right by A and store in C
43 RL A B C: Rotate B left by A and store in C
44 NAND A B C: Store the NAND of A and B in C
45 AND A B C: Store the AND of A and B in C
46 NOR A B C: Store the NOR of A and B in C
47 OR A B C: Store the OR of A and B in C
48 NXOR A B C: Store the NXOR of A and B in C
49 XOR A B C: Store the XOR of A and B in C
50 NOT A B: Store the NOT of A in B
51 GT A B C: Store in C if B is greater than A
52 GTE A B C: Store in C if B is greater than or equal to A
53 LT A B C: Store in C if B is less than A
54 LTE A B C: Store in C if B is less than or equal to A
55 EQ A B C: Store in C if B is equal to A
56 NEQ A B C: Store in C if B is not equal to A

Debug
-----
60 DBG A: Debug use
61 PAU: Pause execution