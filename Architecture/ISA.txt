Registers
---------
R0-R15: General purpose use
RI0-RI7: General purpose use for interrupts only
RO: 0x00.. register
RF: 0xFF.. register
RSP: Address of the current stack position
RIP: Address of the current instruction
RSIP: Address of the instruction executing when an interrupt fires
RCFG: Physical address of the processor configuration table
RIDT: Physical address of the interrupt descriptor table
RMDT: Physical address of the memory descriptor table
RTDT: Physical address of the task descriptor table
RINT: Data made available from an interrupt

CFG
---
2b: system tick interval
2b: cached instructions
1b: protection mode (0 = no protection, 1 = protected)

IDT
---
0x00: Invalid instruction
0x01: Divide by zero
0x02: System call
0x03: Protection violation
0x04: Page not present
0x05: System timer
0x06: Device waiting
0x07-0x0F: Reserved
0x10-0xFF: User defined

Instruction Format
------------------
Each instruction is one word followed by three optional literal words (13 if using three calculated parameters).

8b Code
8b Reserved
24b Registers (8b each)
15b Reserved
9b Parameter Types (3b each)
    0 = calculated value (base + index * scale + offset), 
    1 = calculated value as address to dereference, 
    2 = register, 
    3 = register value as address to dereference, 
    4 = literal value, 
    5 = literal value as address to dereference, 
    6 = stack, 
    7 = stack value as address to dereference,
0b-768b Parameters: Calculated parameters and literals in order of appearance

Calculated Parameter
--------------------
16b Format (4b for each operand where first 3 are the same as parameter type above (except 6 is default and 7 is not defined) and the fourth is a sign bit)
32b Register operands
16b Reserved
0b-256b Literal operands

Basic
-----
00 HLT: Stops the processor
01 NOP: No operation
02 INT A: Raise the interrupt specified by A
03 EINT: Return from the interrupt
04 INTE: Enables interrupts
05 INTD: Disables interrupts
06 MOV A B: Move A into B
07 MVZ A B C: Moves B into C if A is zero
08 MVNZ A B C: Moves B into C if A is non-zero
09 XCHG A B: Swap A and B
10 IN A B: Read from device ID specified in A into B
11 OUT A B: Write to device ID specified in A from B

Math
----
20 ADD A B C: Add A to B and store in C
21 ADDF A B C: Add the IEEE 754 value in A to B and store in C
22 SUB A B C: Subtract A from B and store in C
23 SUBF A B C: Subtract the IEEE 754 value in A from B and store in C
24 DIV A B C: Divide B by A and store in C
25 DIVF A B C: Divide B by the IEEE 754 value in A and store in C
26 MUL A B C: Multiply B by A and store in C
27 MULF A B C: Multiply B by the IEEE 754 value in A and store in C
28 MOD A B C: Take the remainder of dividing B by A and store in C
29 MODF A B C: Take the remainder of dividing B by the IEEE 754 value in A and store in C

Logic
-----
40 SR A B C: Shift B right by A and store in C
41 SL A B C: Shift B left by A and store in C
42 RR A B C: Rotate B right by A and store in C
43 RL A B C: Rotate B left by A and store in C
44 NAND A B C: Store the NAND of A and B in C
45 AND A B C: Store the AND of A and B in C
46 NOR A B C: Store the NOR of A and B in C
47 OR A B C: Store the OR of A and B in C
48 NXOR A B C: Store the NXOR of A and B in C
49 XOR A B C: Store the XOR of A and B in C
50 NOT A B: Store the NOT of A in B
51 GT A B C: Store in C if B is greater than A
52 GTE A B C: Store in C if B is greater than or equal to A
53 LT A B C: Store in C if B is less than A
54 LTE A B C: Store in C if B is less than or equal to A
55 EQ A B C: Store in C if B is equal to A
56 NEQ A B C: Store in C if B is not equal to A

Debug
-----
60 DBG A: Debug use
61 PAU: Pause execution